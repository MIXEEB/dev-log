
Disclaimer:. Observed behavior occured web3-eth-contract:4.0.5. But this story is about exploration, not the particular behavior, however .

1. Ready to run
I have deployed MiniatureTrading smart contract, implemented web application to interact with it. And it was perfect time to add minting function.
Going straight to point. Here is function that is sending mint transaction.
[code]
Looks fine, correct? Lets double check documentaion. A nice sample:
[code]
Its time to run, you have added data, pressed mint, and the last thing you have expected: Transaction Failed.

2. Workaroung
Etherscan is your friend, when you try to figure out failure reason. And it didn't let me down this time either
I've opened transaction details, ready to compare data send by my app and remix IDE. But there was nothing to compare - 0x stared at me(or vice versa)
[screenshot]
But I wanted my miniature to be minted, so I tried raw approach:
[code].
You guessed it, that worked. But why should I use this blunt approach, when I have my neat contract object, right?
I have modified transaction options and added data explicity with encodeABI. Worked as intended, and galery was filled with new miniature.
[code]

3. Debugging
So you are wondering why it didn't work initially, and so did I. And noone would provide with answers better than web3 library itself.
My debug journey brough me to particular function of utils.js file into web3-eth-contract: getSendTxParams
the following piece if where out transaction parameters object is constructed, notably no data param is set explicitly here.
As you might guessed, when data is provided via transaction options, it will be there.
[code]
So lets modify this function, do populate data based on our input:
[code]

4. Further action
Now, when I've cleared on details what have happened, there are still open questions. Is this intended behaviour or a bug, thats for me to ask web3.js dev-team.


--
--
--

Title: Solving the Mystery of Failed Transactions in MiniatureTrading

Introduction

In my journey of working with the MiniatureTrading smart contract and the associated web application, I recently encountered an unexpected challenge. 
It was the perfect time to add a minting function to my project. However, things took an interesting turn when I attempted to mint new tokens and found myself facing the dreaded "Transaction Failed" error. 
In this dev-log, I'll take you through my experience, from the issue itself to the workaround, debugging, and my plans for further action.

The Issue

Everything seemed ready for minting. I had successfully deployed the MiniatureTrading smart contract and had implemented a web application for interacting with it.
 The minting function code appeared fine. However, a quick double-check of the documentation revealed a peculiar issue - the absence of data in the mint transaction.
 When I initiated the minting process, my expectations were met with disappointment as the transaction failed.

The Workaround

In the world of blockchain development, Etherscan is your trusty companion when you're stuck with transaction failures. I eagerly dove into Etherscan to compare the data sent by my web app with that generated by Remix IDE, only to find a stark difference. The data field was empty, showing nothing but "0x."

Determined to get my miniatures minted, I took a raw approach, manually specifying the data in the transaction. This approach worked, but it left me pondering: why resort to such a blunt method when I had a neat contract object at my disposal? The solution was clear â€“ modifying the transaction options and explicitly adding data with encodeABI. As intended, the gallery was soon filled with the eagerly awaited miniatures.

Debugging

The next logical step was to investigate why the initial approach failed. My quest for answers led me to the inner workings of the web3 library, specifically to a function in utils.js - getSendTxParams. In this function, the transaction parameters object is constructed, and notably, no data parameter is set explicitly. As one might expect, when data is provided via transaction options, it ends up missing. To resolve this, I decided to modify the function to ensure data was populated based on our input.

Further Action

Now that I have a clear understanding of what went wrong and how it was fixed, questions remain. Was this behavior intended, or is it a bug? To find out, I plan to engage with the web3.js dev-team and seek clarification.

In the world of blockchain development, every challenge is an opportunity to learn, and this issue serves as a reminder that even the smallest details matter. Stay tuned for more dev-logs as I continue my journey in the fascinating realm of blockchain and smart contracts.

This revised version maintains the essence of your original content while improving structure, readability, and grammar.


